# Руководство при создании проекта на Python

В данном руководстве будут изложены основные принципы, правила и действия, которые следует
выполнять при создании нового проекта на Python.

Перед тем как прочитать данное руководство, следует ознакомиться со следующим материалом, если
что-то из нижеперечисленного неизвестно/встречается впервые:

- [The Zen of Python](https://peps.python.org/pep-0020/)

- [Git](https://training.github.com/downloads/github-git-cheat-sheet.pdf)

- [PEP 8](https://peps.python.org/pep-0008/)

- [Virtual Environment in Python](https://docs.python.org/3/library/venv.html)

- [Poetry](https://python-poetry.org/docs/)

- [The Black code style](https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html)

- [Pydantic](https://docs.pydantic.dev/latest/)

- [Pydantic Settings Management](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)

- [Env. files](https://www.geeksforgeeks.org/how-to-create-and-use-env-files-in-python/)

- [SOLID principles](https://realpython.com/solid-principles-python/)

## Git Репозиторий

Перед тем как приступить к работе над проектом, нужно обязательно создать репозиторий на GitHub
для того, чтобы, во-первых, версионировать проект, а во-вторых, чтобы помочь другому разработчику
проследить логику создания и разработки проекта при учете, что коммиты совершаются
последовательно, файл за файлом, а не одним единственным коммитом.

Соответственно нужно следить за коммитами и вовремя их создавать, а также при изменении
нескольких файлов следует коммитить файлы не вместе, а поочередно.
При создании нового репозитория на GitHub нужно обязательно добавлять создание файла gitignore с
шаблоном Python.

Также желательно сразу создавать README файл, который должен содержать описание проекта и его
функционала.

## Виртуальное окружение и Poetry

После того как репозиторий создан, его нужно клонировать в локальную директорию.

Затем открыть папку с репозиторием в любой удобной среде разработке и далее выполнить следующие
действия:

1. В корне проекта создаем виртуальное окружение под названием venv. Мы всегда используем
название venv, так как каталог с таким названием уже учитывается в файле gitignore и
соответственно не будет индексироваться и загружаться на гитхаб

2. Активируем виртуальное окружение и проверяем, что у нас в переменных окружения используется
интерпретатор и менеджер пакетов виртуального окружения. Это можно сделать командой (для windows)
where pip и where python или (для linux) which pip и which python

3. Далее устанавливаем в виртуальное окружение через pip Poetry

```shell
>>>pip install poetry
```

4. Через poetry устанавливаем необходимые зависимости для проекта и коммитим полученные изменения
(pyproject.toml и poetry.lock)

Смысл этих шагов заключается в том, что нам всегда необходимо создавать изолированную среду, не
привязанную к глобальному окружению, чтобы потом развернуть проект также изолированно со своим
окружением на другом компьютере или сервере или какой-либо платформе. 

Более того, благодаря Poetry мы всегда можем отслеживать изменения не только в главных
зависимостях, но и в субзависимостях, а также задавать определенные ограничения на обновление
пакетов. Таким образом, другому разработчику будет удобно развернуть этот проект как у себя, так
и на сервере и, главное, не будет проблем с конфликтом версий.

## Форматер Black

Следующим шагом нужно установить форматер Black через команду:

```shell
>>>poetry add black
```

С помощью этого форматера стиль кода будет унифицирован во всех python файлах согласно PEP8.
Таким образом, не нужно всегда помнить, какого стиля придерживаться, black сам приведет весь код
к стандартному виду.

## Архитектура проекта

Теперь перейдем к рассмотрению архитектуры проекта на python.

То, какая конкретно  архитектура будет у проекта, зависит от самого проекта, однако нужно
придерживаться общих правил с учетом *дзэна Python*, а также пяти принципов ООП – **SOLID**.

>Namespaces are one honking great idea -- let's do more of those

Одним из девизов Python является создание как можно больших пространств имен. Под пространством
имен в данном контексте подразумевается python модуль, в котором определятся классы, функции,
константы и т.д. 

Поэтому нужно как можно больше декомпозировать код по разным модулям, отводя небольшому
функционалу отдельный python модуль. Не нужно весь код, всю логику описывать одним массивным
модулем или даже двумя/тремя модулями. Если модуль содержит больше 100 строчек кода, то нужно
задуматься о рефакторинге кода и вынесении функционала в отдельные модули, так как скорее всего
получаются громоздкие функции/классы и т. д. Сами функции и методы классов также не должны быть
большими, они должны выполнять одно действие/операцию. 

### Модуль main.py

Обязательно должен присутствовать исполняемый модуль, точка входа под названием main.py. 

Данный модуль также не должен быть громоздким, а содержать импорты из модулей с основной логикой
вспомогательными функциями и т. д. 

В главном исполняемом файле должна обязательна присутствовать такая строчка кода:

```python
if __name__ = "__main__":
    main()
```

Функция main содержит вызовы функций/методов класса, в общем исполняемый код.
Таким образом, при импорте главного файла (например, при тестировании) мы гарантируем то, что
проект не будет запущен. 

### Каталог tests

Также не стоит забывать выделять отдельный каталог в проекте под тесты, которые, например, можно запускать через пакет **pytest**.

### Шаблоны структуры проекта

Если проект основан на каком-либо фреймворке, то можно поискать, например, на Github примерные
архитектуры на данном фреймворке. При создании проекта на Django сам фреймворк задает уже
определенную структуру, поэтому в данном случае мы используем то, что уже имеется.

Однако для FastAPI можно, например, придерживаться [такой](https://github.com/mahenzon/FastAPI-base-app) архитектуры проекта.

### Конфигурация проекта, модуль config.py

В отдельный файл также нужно выносить конфигурационные настройки проекта. Например, в модуль под
названием **config.py**.

В этом файле можно определить классы, которые будут наследоваться от класса **BaseModel**,
импортируемого из Pydantic и в этом классе указать переменные и их типы, чтобы Pydantic провел
валидацию и выдавал исключение при вводе некорректных значений конфигурационных переменных.

Также следует создать главный класс с настройками, который будет наследоваться от
**BaseSettings**. В нем мы инстанцинируем классы настроек, а также через класс
**SettingsConfigDict** мы можем автоматически импортировать значения из файла *env.*.

В таком виде удобно менять значения в файле env. внутри классов, кроме того можно всегда быть
уверенным, что все значение введены корректно, благодаря валидации Pydentic.

Пример такого модуля можно посмотреть по [ссылке]( https://github.com/mahenzon/FastAPI-base-app/blob/master/fastapi-application/core/config.py).